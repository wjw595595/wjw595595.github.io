<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-c86a9ea2-1d30-467c-a8ac-35c914a4b978"></attachment><p># 准备环境 | 系统 | ip地址 | 实例名 | | --------------------- | ---------------------------------------- | ------ | | 主库（pd）：centos7.8 | 192.168.210.91 | orcl | | 备库（st）：centos7.8 | 192.168.210.92 | orcl | | 软件版本 | Oracle Database 11g Release 2 (11.2.0.4) | | oracle 密码：Aa123456 数据库密码： 123456Aa 说明： 首先得准备两个能够PING通，并且装了Oracle软件且已经建库的Linux虚拟机。操作系统不限，至少有一个虚拟机已经建好库，最好两个都建好相同SID的库，这样少很多创建目录的麻烦，这里库的SID都是orcl，Linux严格区分大小写，所以SID的大小写得注意。 # 主备库配置静态监听 ## 主库监听和tns配置 ``` vi $ORACLE_HOME/network/admin/listener.ora ``` ```powershell LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.91)(PORT = 1521)) ) ) ) SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (GLOBAL_DBNAME = orcl) (ORACLE_HOME = /data/oracle/product/11.2.0/db_1) (SID_NAME = orcl) ) ) ``` ``` vi $ORACLE_HOME/network/admin/tnsnames.ora ``` ```powershell ORCL_PD = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.91)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) ) ORCL_ST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.92)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) ) ``` ## 从库配置监听和tns ``` vi $ORACLE_HOME/network/admin/listener.ora ``` ```powershell LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.92)(PORT = 1521)) ) ) ) SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (GLOBAL_DBNAME = orcl) (ORACLE_HOME = /data/oracle/product/11.2.0/db_1) (SID_NAME = orcl) ) ) ``` ``` vi $ORACLE_HOME/network/admin/tnsnames.ora ``` ``` ORCL_PD = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.91)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) ) ORCL_ST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.92)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) ) ``` ## 主库修改配置 ### 主库开启强制日志和归档 ```sql sqlplus / as sysdba SQL&gt; shutdow immediate SQL&gt;startup mount; #开启强日志 SQL&gt; alter database force logging;--修改数据库为强制记日志，这是必须的操作，主库的每一步操作都得记录到日志中去。 #开启归档 SQL&gt; alter database archivelog; --修改数据库为归档模式，因为dg是通过传送归档日志到备库然后应用来保证主备库一致的。 SQL&gt;archive log list ; SQL&gt; archive log list ; Database log mode Archive Mode Automatic archival Enabled Archive destination /data/oracle/oradata/orcl/archivelog Oldest online log sequence 23 Next log sequence to archive 25 Current log sequence 25 ``` ### 查看主库日志，添加备用日志 ```sql SQL&gt; select group#, member from v$logfile; GROUP# ---------- MEMBER -------------------------------------------------------------------------------- 3 /data/oracle/oradata/orcl/redo03.log 2 /data/oracle/oradata/orcl/redo02.log 1 /data/oracle/oradata/orcl/redo01.log ``` 添加 ```sql alter database add standby logfile '/data/oracle/oradata/orcl/redo04.log' size 50M ; alter database add standby logfile '/data/oracle/oradata/orcl/redo05.log' size 50M ; alter database add standby logfile '/data/oracle/oradata/orcl/redo06.log' size 50M ; alter database add standby logfile '/data/oracle/oradata/orcl/redo07.log' size 50M ; ``` ### 修改 pd（主）端初始化参数文件 spfile 因为spfile是二进制文件不能直接修改，要先生成pfile 文本文件，修改文本文件 ，然后再用文本文件启动生成新的spfile文件 ```sql SQL&gt; show parameter spfile NAME TYPE ------------------------------------ ---------------------- VALUE ------------------------------ spfile string /data/oracle/product/11.2.0/db_1/dbs/spfileorcl.ora ``` #### 创建pfile ```sql SQL&gt; create pfile from spfile;--这里创建pfile是为了做一些主库参数的配置，并且还得拷贝到备库再次修改成备库的配置。 ``` 创建的pfile默认在$ORACLE_HOME/dbs目录下 ，文件名是 init+实例名.ora ``` -rw-r--r-- 1 oracle dba 1571 Dec 2 21:03 initorcl.ora ``` #### 创建归档目录--（这个要探讨一下） archive log list; --其中Archive destination就是归档目录 ``` SQL&gt; archive log list; Database log mode Archive Mode Automatic archival Enabled Archive destination /data/oracle/oradata/orcl/archivelog Oldest online log sequence 23 Next log sequence to archive 0 Current log sequence 25 ``` ```sql cd /data/oracle/oradata/orcl mkdir archivelog --建立这个目录是为了存放主库的归档日志文件，并且这个目录会和其他数据文件等等一起拷贝到备库。 ``` #### 修改pfile ```shell orcl.__db_cache_size=1811939328 orcl.__java_pool_size=16777216 orcl.__large_pool_size=100663296 orcl.__oracle_base='/data/oracle'#ORACLE_BASE set from environment orcl.__pga_aggregate_target=822083584 orcl.__sga_target=2466250752 orcl.__shared_io_pool_size=0 orcl.__shared_pool_size=503316480 orcl.__streams_pool_size=0 *.audit_file_dest='/data/oracle/admin/orcl/adump' *.audit_trail='db' *.compatible='11.2.0.4.0' *.control_files='/data/oracle/oradata/orcl/control01.ctl','/data/oracle/fast_recovery_area/orcl/control02.ctl' *.db_block_size=8192 *.db_domain='' *.db_name='orcl' *.db_recovery_file_dest='/data/oracle/fast_recovery_area' *.db_recovery_file_dest_size=4385144832 *.diagnostic_dest='/data/oracle' *.dispatchers='(PROTOCOL=TCP) (SERVICE=orclXDB)' *.open_cursors=300 *.pga_aggregate_target=819986432 *.processes=150 *.remote_login_passwordfile='EXCLUSIVE' *.sga_target=2459959296 *.undo_tablespace='UNDOTBS1' #by wjw new add DB_UNIQUE_NAME=orcl_pd LOG_ARCHIVE_CONFIG='DG_CONFIG=(orcl_pd,orcl_st)' LOG_ARCHIVE_DEST_1= 'LOCATION=/data/oracle/oradata/orcl/archivelog VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=orcl_pd' LOG_ARCHIVE_DEST_2= 'SERVICE=orcl_st ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=orcl_st' LOG_ARCHIVE_DEST_STATE_1=ENABLE LOG_ARCHIVE_DEST_STATE_2=ENABLE #REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE LOG_ARCHIVE_FORMAT=%t_%s_%r.arc FAL_SERVER=orcl_st LOG_ARCHIVE_MAX_PROCESSES=4 #DB_FILE_NAME_CONVERT='orcl_st','orcl_pd' #LOG_FILE_NAME_CONVERT='orcl_st','orcl_pd' STANDBY_FILE_MANAGEMENT=AUTO ``` 空行之后是新加的 下面有注释掉的两行DB_NAME和REMOTE_LOGIN_PASSWORDFILE两项，是因为上面有，所以注释了，如果上面没有，就需要放开注释 #### 用新修改的pfile启动主库 ```sql SQL&gt; shutdown immediate ; Database closed. Database dismounted. ORACLE instance shut down. --用pfile文件 nomount模式启动 SQL&gt; startup nomount pfile='/data/oracle/product/11.2.0/db_1/dbs/initorcl.ora' SQL&gt; select instance_name,status from v$instance ; INSTANCE_NAME STATUS ---------------- ------------ orcl STARTED ---根据新的pfile创建spfile文件 SQL&gt; create spfile from pfile ; File created. --新建的spfile也会在默认的$ORACLE_HOME/dbs/spfiletcc.ora下面 oracle11@scc[/oracle11/product/112/dbs]$ll -rw-r----- 1 oracle dba 2560 Dec 2 20:05 spfileorcl.ora ``` #### 再次停库然后重启，此时使用默认的spfile文件 ```sql SQL&gt; shutdown immediate ; ORA-01507: database not mounted ORACLE instance shut down. SQL&gt; SQL&gt; startup ORACLE instance started. Total System Global Area 2471931904 bytes Fixed Size 2255752 bytes Variable Size 553649272 bytes Database Buffers 1895825408 bytes Redo Buffers 20201472 bytes Database mounted. Database opened. SQL&gt; show parameter pfile NAME TYPE VALUE ------------------------------------ ----------- ------------------------------ spfile string /oracle11/product/112/dbs/spfi lescc.ora SQL&gt; ``` #### 将口令验证文件和pfile发送到备库（备注 如果实例名不同,相应的文件名 orapw+实例名 init+实例名.ora） ```shell scp orapworcl 192.168.210.91:/data/oracle/product/11.2.0/db_1/dbs/ (可以加文件名) scp initorcl.ora 192.168.210.91:/data/oracle/product/11.2.0/db_1/dbs/ ``` 备库修改initorcl.ora 文件 ```shell orcl.__db_cache_size=1811939328 orcl.__java_pool_size=16777216 orcl.__large_pool_size=100663296 orcl.__oracle_base='/data/oracle'#ORACLE_BASE set from environment orcl.__pga_aggregate_target=822083584 orcl.__sga_target=2466250752 orcl.__shared_io_pool_size=0 orcl.__shared_pool_size=503316480 orcl.__streams_pool_size=0 *.audit_file_dest='/data/oracle/admin/orcl/adump' *.audit_trail='db' *.compatible='11.2.0.4.0' *.control_files='/data/oracle/oradata/orcl/control01.ctl','/data/oracle/fast_recovery_area/orcl/control02.ctl' *.db_block_size=8192 *.db_domain='' *.db_name='orcl' *.db_recovery_file_dest='/data/oracle/fast_recovery_area' *.db_recovery_file_dest_size=4385144832 *.diagnostic_dest='/data/oracle' *.dispatchers='(PROTOCOL=TCP) (SERVICE=orclXDB)' *.open_cursors=300 *.pga_aggregate_target=819986432 *.processes=150 *.remote_login_passwordfile='EXCLUSIVE' *.sga_target=2459959296 *.undo_tablespace='UNDOTBS1' #by wjw DB_UNIQUE_NAME=orcl_st LOG_ARCHIVE_CONFIG='DG_CONFIG=(orcl_pd,orcl_st)' LOG_ARCHIVE_DEST_1= 'LOCATION=/data/oracle/oradata/orcl/archivelog VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=orcl_st' LOG_ARCHIVE_DEST_2= 'SERVICE=orcl_st ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=orcl_pd' LOG_ARCHIVE_DEST_STATE_1=ENABLE LOG_ARCHIVE_DEST_STATE_2=ENABLE #REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE LOG_ARCHIVE_FORMAT=%t_%s_%r.arc FAL_SERVER=orcl_pd LOG_ARCHIVE_MAX_PROCESSES=4 #DB_FILE_NAME_CONVERT='orcl_st','orcl_pd' #LOG_FILE_NAME_CONVERT='orcl_st','orcl_pd' STANDBY_FILE_MANAGEMENT=AUTO ``` 各种参数参考文档： http://blog.itpub.net/28974745/viewspace-2136427/ https://www.cnblogs.com/elontian/p/10079756.html https://www.cnblogs.com/dayu-liu/p/11045980.html #### 启动备库到nomount阶段 ```sql SQL&gt; startup nomount --如果不行可以带文件启动 SQL&gt; startup nomount pfile='/data/oracle/product/11.2.0/db_1/dbs/initorcl.ora' --主备的时候备库要启动在nomount模式 ``` #### 测试tns tnsping orcl_pd tnsping orcl_st ``` [oracle@localhost dbs]$ tnsping orcl_pd TNS Ping Utility for Linux: Version 11.2.0.4.0 - Production on 04-DEC-2020 15:35:33 Copyright (c) 1997, 2013, Oracle. All rights reserved. Used parameter files: Used TNSNAMES adapter to resolve the alias Attempting to contact (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.210.91)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl))) OK (0 msec) ``` ## 用rman进行adg （在主库执行） ### 在primary端通过Rman Duplicate创建备库 ```shell 11g: 在主机执行 rman target / auxiliary sys/123456Aa@orcl_st #12c：rman target sys/123456Aa@orcl_pd auxiliary sys/123456Aa@orcl_st ``` ``` RMAN&gt; duplicate target database for standby from active database nofilenamecheck; ``` **#至此已经恢复完成** ### 检查 复制完成后可以查看备库状态 处于MOUNT，角色是物理备库: ```sql SQL&gt; select database_role, open_mode from v$database; DATABASE_ROLE OPEN_MODE ---------------- -------------------- PHYSICAL STANDBY MOUNTED SQL&gt; select status from v$instance; STATUS ------------ MOUNTED SQL&gt; ``` 此时主库状态，处于OPEN，可读写，默认为最大性能模式： ```sql SQL&gt; select database_role, open_mode from v$database; DATABASE_ROLE OPEN_MODE ---------------- -------------------- PRIMARY READ WRITE SQL&gt; select status from v$instance; STATUS ------------ OPEN SQL&gt; select PROTECTION_MODE from v$database; PROTECTION_MODE -------------------- MAXIMUM PERFORMANCE SQL&gt; ``` ### 打开备库并开启apply service 或可以说 切换ADG 备库执行 ``` sqlplus / as sysdba SQL&gt; recover managed standby database using current logfile disconnect from session; Media recovery complete. SQL&gt; recover managed standby database cancel; Media recovery complete. SQL&gt; alter database open; Database altered. SQL&gt; select database_role, open_mode from v$database; DATABASE_ROLE OPEN_MODE ---------------- -------------------- PHYSICAL STANDBY READ ONLY ``` 其中disconnect from session表示后台执行，类似于shell的&amp;。可以看出现在备库处于READ ONLY状态，不再是处于MOUNT不可使用的状态，即现在可以执行只读操作了。 ``` SQL&gt; recover managed standby database using current logfile disconnect from session; Media recovery complete. SQL&gt; select database_role, open_mode from v$database; DATABASE_ROLE OPEN_MODE ---------------- -------------------- PHYSICAL STANDBY READ ONLY WITH APPLY ``` 此时数据库状态时READ ONLY WITH APPLY，即只读且实时应用日志，通常所说的ADG，Active Data Guard。 READ ONLY WITH APPLY表示备库处于READ ONLY状态的同时可以接收主库传过来的日志文件并进行恢复，以便备库可以即时查看到主库的变化。 此时adg已经搭建完成了，可以测试一下效果。 测试主库 ```sql SQL&gt; create table wufan(name varchar2(20),passwd varchar2(30)); Table created. SQL&gt; insert into wufan values('wufan','123456'); 1 row created. SQL&gt; commit; Commit complete. SQL&gt; ``` 备库可以直接去查看下表和数据是否过去了 ```sql SQL&gt; desc wufan Name Null? Type ----------------------------------------- -------- ---------------------------- NAME VARCHAR2(20) PASSWD VARCHAR2(30) SQL&gt; select * from wufan ; NAME PASSWD -------------------- ------------------------------ wufan 123456 ``` 主要参考文章： https://blog.csdn.net/kadwf123/article/details/81509002 https://blog.csdn.net/DBDeep/article/details/78245699 https://blog.csdn.net/wuweilong/article/details/46549415</p><p><br></p>