<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-1ae9c752-6868-445f-b7a8-3957e4c4483f"></attachment><p>要从奔溃的 RabbitMQ 中恢复的消息，我们需要做消息持久化。如果消息要从 RabbitMQ 奔溃中恢复，那么必须满足三点，且三者缺一不可。</p><ul><li>交换器必须是持久化。</li><li>队列必须是持久化的。</li><li>消息必须是持久化的。</li></ul><p><strong>原生的实现方式</strong></p><p>原生的 RabbitMQ 客户端需要完成三个步骤。</p><p>第一步，交换器的持久化。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数1 exchange ：交换器名</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数2 type ：交换器类型</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数3 durable ：是否持久化</code></p><p><code style="color: black; background-color: rgb(255, 255, 255);">channel.exchangeDeclare(EXCHANGE_NAME, </code><code style="color: blue; background-color: rgb(255, 255, 255);">"topic"</code><code style="color: black; background-color: rgb(255, 255, 255);">, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>true</strong></code><code style="color: black; background-color: rgb(255, 255, 255);">);</code></p><p>第二步，队列的持久化。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p class="ql-align-right">5</p><p class="ql-align-right">6</p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数1 queue ：队列名</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数2 durable ：是否持久化</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数5 arguments</code></p><p><code style="color: black; background-color: rgb(255, 255, 255);">channel.queueDeclare(QUEUE_NAME, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>true</strong></code><code style="color: black; background-color: rgb(255, 255, 255);">, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>false</strong></code><code style="color: black; background-color: rgb(255, 255, 255);">, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>false</strong></code><code style="color: black; background-color: rgb(255, 255, 255);">, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>null</strong></code><code style="color: black; background-color: rgb(255, 255, 255);">);</code></p><p>第三步，消息的持久化。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p class="ql-align-right">5</p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数1 exchange ：交换器</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数2 routingKey ： 路由键</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数3 props ： 消息的其他参数,其中 MessageProperties.PERSISTENT_TEXT_PLAIN 表示持久化</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数4 body ： 消息体</code></p><p><code style="color: black; background-color: rgb(255, 255, 255);">channel.basicPublish(</code><code style="color: blue; background-color: rgb(255, 255, 255);">""</code><code style="color: black; background-color: rgb(255, 255, 255);">, queue_name, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</code></p><p><strong>Spring AMQP 的实现方式</strong></p><p>Spring AMQP 是对原生的 RabbitMQ 客户端的封装。一般情况下，我们只需要定义交换器的持久化和队列的持久化。</p><p>其中，交换器的持久化配置如下。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数1 name ：交互器名</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数2 durable ：是否持久化</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数3 autoDelete ：当所有消费客户端连接断开后，是否自动删除队列</code></p><p><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>new</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">TopicExchange(name, durable, autoDelete)</code></p><p>此外，还需要再配置队列的持久化。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p class="ql-align-right">5</p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数1 name ：队列名</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数2 durable ：是否持久化</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</code></p><p><code style="color: rgb(0, 130, 0); background-color: rgb(255, 255, 255);">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</code></p><p><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>new</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Queue(name, durable, exclusive, autoDelete);</code></p><p>至此，RabbitMQ 的消息持久化配置完毕。</p><p>那么，消息的持久化难道不需要配置么？确实如此，我们来看下源码。</p><p>一般情况下，我们会通过这种方式发送消息。</p><p class="ql-align-right">1</p><p><code style="color: black; background-color: rgb(255, 255, 255);">rabbitTemplate.convertAndSend(exchange, routeKey, message);</code></p><p>其中，调用了 convertAndSend(String exchange, String routingKey, final Object object) 方法。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p><code style="color: gray; background-color: rgb(255, 255, 255);">@Override</code></p><p><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>public</strong></code> <code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>void</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">convertAndSend(String exchange, String routingKey, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>final</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Object object) </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>throws</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">AmqpException {</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">convertAndSend(exchange, routingKey, object, (CorrelationData) </code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>null</strong></code><code style="background-color: rgb(255, 255, 255); color: black;">);</code></p><p><code style="color: black; background-color: rgb(255, 255, 255);">}</code></p><p>接着，用调用了 convertAndSend(String exchange, String routingKey, final Object object, CorrelationData correlationData) 方法。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>public</strong></code> <code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>void</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">convertAndSend(String exchange, String routingKey, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>final</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Object object, CorrelationData correlationData) </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>throws</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">AmqpException {</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">send(exchange, routingKey, convertMessageIfNecessary(object), correlationData);</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">}</code></p><p>此时，最关键的方法出现了，它是 convertMessageIfNecessary(final Object object)。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p class="ql-align-right">5</p><p class="ql-align-right">6</p><p><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>protected</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Message convertMessageIfNecessary(</code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>final</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Object object) {</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>if</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">(object </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>instanceof</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Message) {</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>return</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">(Message) object;</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">}</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>return</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">getRequiredMessageConverter().toMessage(object, </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>new</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">MessageProperties());</code></p><p><code style="color: black; background-color: rgb(255, 255, 255);">}</code></p><p>其中，关键的是 MessageProperties 类,它持久化的策略是 MessageDeliveryMode.PERSISTENT，因此它会初始化时默认消息是持久化的。</p><p class="ql-align-right">1</p><p class="ql-align-right">2</p><p class="ql-align-right">3</p><p class="ql-align-right">4</p><p class="ql-align-right">5</p><p class="ql-align-right">6</p><p class="ql-align-right">7</p><p class="ql-align-right">8</p><p class="ql-align-right">9</p><p class="ql-align-right">10</p><p><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>public</strong></code> <code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>class</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">MessageProperties </code><code style="color: rgb(0, 102, 153); background-color: rgb(255, 255, 255);"><strong>implements</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">Serializable {</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>public</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">MessageProperties() {</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>this</strong></code><code style="background-color: rgb(255, 255, 255); color: black;">.deliveryMode = DEFAULT_DELIVERY_MODE;</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>this</strong></code><code style="background-color: rgb(255, 255, 255); color: black;">.priority = DEFAULT_PRIORITY;</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">}</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 102, 153);"><strong>static</strong></code> <code style="color: black; background-color: rgb(255, 255, 255);">{</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">DEFAULT_PRIORITY = Integer.valueOf(</code><code style="background-color: rgb(255, 255, 255); color: rgb(0, 153, 0);">0</code><code style="background-color: rgb(255, 255, 255); color: black;">);</code></p><p><code style="background-color: rgb(255, 255, 255);">&nbsp;</code><code style="background-color: rgb(255, 255, 255); color: black;">}</code></p><p><code style="color: black; background-color: rgb(255, 255, 255);">}</code></p><p><br></p>